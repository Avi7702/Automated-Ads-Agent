/**
 * Webhook Handler for Observability Alerts
 * 
 * This endpoint receives alerts from Axiom/Grafana and can:
 * 1. Auto-create GitHub Issues for bugs
 * 2. Take automated actions (block users, enable maintenance mode)
 * 3. Notify team via Slack/Discord
 * 
 * Connect your observability platform to POST to /api/webhooks/observability
 */

import { Router } from 'express';
import { telemetry } from '../instrumentation';
import { logger } from '../lib/logger';

const router = Router();

// Types for incoming alerts
interface ObservabilityAlert {
  alertName: string;
  severity: 'info' | 'warning' | 'critical';
  message: string;
  timestamp: string;
  data: {
    endpoint?: string;
    errorType?: string;
    errorCount?: number;
    userId?: string;
    ip?: string;
    threshold?: number;
    currentValue?: number;
    [key: string]: any;
  };
}

// GitHub Issue creation (requires GITHUB_TOKEN env var)
async function createGitHubIssue(title: string, body: string, labels: string[] = ['bug', 'auto-created']) {
  const token = process.env.GITHUB_TOKEN;
  const repo = process.env.GITHUB_REPO; // format: "owner/repo"

  if (!token || !repo) {
    logger.info({ module: 'Webhook' }, 'GitHub not configured, skipping issue creation');
    return null;
  }

  try {
    const response = await fetch(`https://api.github.com/repos/${repo}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ title, body, labels }),
    });

    if (response.ok) {
      const issue = await response.json();
      logger.info({ module: 'Webhook', issueNumber: issue.number, title }, 'Created GitHub Issue');
      return issue;
    } else {
      logger.error({ module: 'Webhook', response: await response.text() }, 'Failed to create GitHub issue');
      return null;
    }
  } catch (error) {
    logger.error({ module: 'Webhook', err: error }, 'Error creating GitHub issue');
    return null;
  }
}

// Slack notification (requires SLACK_WEBHOOK_URL env var)
async function notifySlack(message: string, severity: string) {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL;

  if (!webhookUrl) {
    logger.info({ module: 'Webhook' }, 'Slack not configured, skipping notification');
    return;
  }

  const emoji = severity === 'critical' ? 'ðŸš¨' : severity === 'warning' ? 'âš ï¸' : 'â„¹ï¸';

  try {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `${emoji} *${severity.toUpperCase()}*: ${message}`,
      }),
    });
  } catch (error) {
    logger.error({ module: 'Webhook', err: error }, 'Error sending Slack notification');
  }
}

// Main webhook endpoint
router.post('/observability', async (req, res) => {
  try {
    const alert: ObservabilityAlert = req.body;

    logger.info({ module: 'Webhook', alertName: alert.alertName, severity: alert.severity }, 'Received alert');

    // Handle different alert types
    switch (alert.alertName) {
      // =============================================
      // ERROR SPIKE - Auto-create GitHub Issue
      // =============================================
      case 'high_error_rate':
      case 'error_spike': {
        const issueBody = `
## ðŸ› Automated Bug Report

**Alert:** ${alert.alertName}
**Severity:** ${alert.severity}
**Time:** ${alert.timestamp}

### Details
- **Endpoint:** ${alert.data.endpoint || 'Unknown'}
- **Error Type:** ${alert.data.errorType || 'Unknown'}
- **Error Count:** ${alert.data.errorCount || 'Unknown'}
- **Threshold:** ${alert.data.threshold}
- **Current Value:** ${alert.data.currentValue}

### Context
This issue was automatically created by the observability system when error rates exceeded the threshold.

### Next Steps
1. Check the observability dashboard for detailed traces
2. Review recent deployments
3. Check external service status (Gemini API, database)

---
*Auto-generated by Observability Webhook*
        `;

        await createGitHubIssue(
          `[Auto] Error spike detected on ${alert.data.endpoint || 'API'}`,
          issueBody,
          ['bug', 'auto-created', 'priority-high']
        );
        
        await notifySlack(
          `Error spike detected! ${alert.data.errorCount} errors on ${alert.data.endpoint}. GitHub issue created.`,
          alert.severity
        );
        break;
      }

      // =============================================
      // USER SPENDING LIMIT - Disable user
      // =============================================
      case 'user_spending_limit': {
        const userId = alert.data.userId;

        if (userId) {
          // Here you would disable the user in your database
          // await storage.setUserLimit(userId, { exceeded: true });

          logger.info({ module: 'Webhook', userId }, 'Would disable user for exceeding spending limit');
          
          await notifySlack(
            `User ${userId} exceeded spending limit ($${alert.data.currentValue}). Account flagged.`,
            'warning'
          );
        }
        break;
      }

      // =============================================
      // BRUTE FORCE - Block IP
      // =============================================
      case 'brute_force_detected': {
        const ip = alert.data.ip;

        if (ip) {
          // Here you would block the IP in Redis
          // await redis.sadd('blocked_ips', ip);
          // await redis.expire(`blocked_ip:${ip}`, 86400); // 24 hours

          logger.info({ module: 'Webhook', ip }, 'Would block IP for brute force attempt');
          
          await notifySlack(
            `Brute force detected from IP ${ip}. ${alert.data.errorCount} failed attempts. IP blocked.`,
            'critical'
          );
        }
        break;
      }

      // =============================================
      // GEMINI API DEGRADED - Notify
      // =============================================
      case 'gemini_latency_high':
      case 'external_api_slow': {
        await notifySlack(
          `Gemini API is slow (${alert.data.currentValue}ms avg). This may affect user experience.`,
          'warning'
        );
        break;
      }

      // =============================================
      // DAILY COST EXCEEDED - Notify
      // =============================================
      case 'daily_cost_exceeded': {
        await notifySlack(
          `Daily Gemini cost exceeded $${alert.data.threshold}. Current: $${alert.data.currentValue}`,
          'warning'
        );
        break;
      }

      default:
        logger.info({ module: 'Webhook', alertName: alert.alertName }, 'Unhandled alert type');
    }

    res.json({ received: true, alertName: alert.alertName });
  } catch (error) {
    logger.error({ module: 'Webhook', err: error }, 'Error processing alert');
    res.status(500).json({ error: 'Failed to process alert' });
  }
});

// Health check endpoint
router.get('/observability/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

export default router;





