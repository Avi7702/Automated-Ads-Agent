{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Seed Initial Ad Scene Template Library",
        "description": "Create and upload 10-15 curated visual ad scene templates across all categories to populate the template library for immediate user value",
        "details": "Create a seed script `scripts/seed-templates.ts` that:\n\n1. Uploads preview images to Cloudinary (find free stock images for each category)\n2. Creates template records with comprehensive metadata:\n   - Categories: lifestyle (3), professional (3), outdoor (2), luxury (2), seasonal (2)\n   - Each with: title, description, promptBlueprint with {{product}} placeholder\n   - Platform hints (instagram, linkedin, facebook, twitter, tiktok)\n   - Aspect ratio hints (1:1, 9:16, 16:9, 4:5)\n   - Placement hints (position, scale)\n   - Lighting style, intent, environment, mood, bestForProductTypes\n3. Use storage.saveAdSceneTemplate() to insert\n4. Make templates isGlobal: true for all users\n\nExample template:\n```typescript\n{\n  title: \"Modern Living Room Showcase\",\n  category: \"lifestyle\",\n  promptBlueprint: \"Professional interior photograph of {{product}} installed in a modern minimalist living room with large windows, natural light, neutral color palette, Scandinavian furniture, high-end photography\",\n  platformHints: [\"instagram\", \"pinterest\"],\n  aspectRatioHints: [\"4:5\", \"1:1\"],\n  placementHints: { position: \"center\", scale: \"medium\" },\n  lightingStyle: \"natural\",\n  intent: \"showcase\",\n  environment: \"indoor\",\n  mood: \"minimal\",\n  bestForProductTypes: [\"flooring\", \"furniture\", \"decor\"]\n}\n```\n\nRun with: `npx tsx scripts/seed-templates.ts`",
        "testStrategy": "1. Run seed script successfully\n2. Query database: `SELECT COUNT(*) FROM ad_scene_templates WHERE is_global = true` (expect 10-15)\n3. Verify Cloudinary uploads via dashboard\n4. Test GET /api/ad-templates returns seeded data\n5. Verify template matching works with test product",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:46:37.588Z"
      },
      {
        "id": "2",
        "title": "Implement Template Library API Endpoints",
        "description": "Complete the template CRUD API endpoints for browsing, filtering, and managing ad scene templates",
        "details": "In `server/routes.ts`, add the following endpoints:\n\n**GET /api/ad-templates**\n- Query params: category, platform, aspectRatio, tags[], intent, environment, mood\n- Filter using storage.getAdSceneTemplates()\n- Return: `{ templates: AdSceneTemplate[], total: number }`\n- Support pagination (optional): limit, offset\n\n**GET /api/ad-templates/:id**\n- Fetch single template by ID\n- Return 404 if not found\n- Include all metadata fields\n\n**POST /api/ad-templates** (admin only)\n- Require auth: requireAuth middleware\n- Validate request body against insertAdSceneTemplateSchema\n- Accept multipart/form-data for preview image upload\n- Upload to Cloudinary, extract URL + publicId\n- Save via storage.saveAdSceneTemplate()\n- Return created template\n\n**DELETE /api/ad-templates/:id** (admin only)\n- Require auth + ownership check (createdBy === userId OR isGlobal === false)\n- Delete from Cloudinary using publicId\n- Delete from database\n- Return 204 on success\n\nReuse existing patterns from product endpoints for consistency.",
        "testStrategy": "1. Unit tests in `server/__tests__/templates.test.ts`:\n   - Test filtering by each parameter\n   - Test pagination\n   - Test create with image upload\n   - Test delete authorization\n2. Integration test: Create template via POST, verify GET returns it\n3. Manual test: Use Postman/curl to test all endpoints\n4. Verify rate limiting applies (100 req/15min)",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:51:06.037Z"
      },
      {
        "id": "3",
        "title": "Extend Transform Endpoint for Template Modes",
        "description": "Enhance /api/transform to support exact_insert, inspiration, and standard generation modes with template integration",
        "details": "Modify `server/routes.ts` POST /api/transform:\n\n1. **Add new request fields:**\n```typescript\ninterface TransformRequest {\n  // Existing fields...\n  mode?: 'exact_insert' | 'inspiration' | 'standard'; // default: 'standard'\n  templateId?: string; // Required if mode !== 'standard'\n}\n```\n\n2. **Template processing logic:**\n- If templateId provided: fetch template via storage.getAdSceneTemplateById()\n- For exact_insert mode:\n  - Include template.referenceImages in Gemini request as reference\n  - Merge template.promptBlueprint with user prompt\n  - Replace {{product}} placeholder with product name/description\n  - Use template.placementHints for positioning instructions\n- For inspiration mode:\n  - Use template.promptBlueprint as style guide\n  - Extract mood, lightingStyle, environment from template\n  - Generate new scene maintaining template aesthetics\n- For standard mode (default): existing behavior, no template\n\n3. **Prompt engineering:**\n```typescript\nfunction buildTemplatePrompt(mode, template, userPrompt, product) {\n  if (mode === 'exact_insert') {\n    return `${template.promptBlueprint.replace('{{product}}', product.name)}. ${userPrompt}. Product placement: ${template.placementHints.position}, size: ${template.placementHints.scale}`;\n  }\n  if (mode === 'inspiration') {\n    return `Create a ${template.mood} ${template.environment} scene inspired by: \"${template.description}\". Lighting style: ${template.lightingStyle}. Feature product: ${product.name}. ${userPrompt}`;\n  }\n  return userPrompt; // standard mode\n}\n```\n\n4. **Add template metadata to generation record:**\n- Store templateId, mode in generations.conversationHistory as metadata",
        "testStrategy": "1. Test each mode with same product:\n   - exact_insert: product appears in template scene\n   - inspiration: new scene with template's mood/style\n   - standard: no template influence\n2. Test template.referenceImages inclusion in API call\n3. Verify placeholder replacement works correctly\n4. Test missing templateId with mode=exact_insert (should error)\n5. Integration test: Create generation with each mode, verify output quality",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:52:29.491Z"
      },
      {
        "id": "4",
        "title": "Build Template Library Frontend Component",
        "description": "Create a browsable template gallery UI with filters, preview modal, and mode selection for template-based generation",
        "details": "Create `client/src/components/TemplateLibrary.tsx`:\n\n**Features:**\n1. **Grid layout** (3-4 columns, responsive)\n   - Template cards with thumbnail (previewImageUrl)\n   - Title, category badge, platform/aspect ratio icons\n   - Hover effect showing description\n\n2. **Filtering sidebar:**\n   - Category dropdown (lifestyle, professional, outdoor, luxury, seasonal)\n   - Platform checkboxes (instagram, linkedin, facebook, twitter, tiktok)\n   - Aspect ratio toggles (1:1, 9:16, 16:9, 4:5)\n   - Intent/mood filters (optional)\n   - \"Clear filters\" button\n\n3. **Preview modal** (click template card):\n   - Large preview image\n   - Full description, metadata (category, tags, platform hints)\n   - Prompt blueprint preview (truncated with \"show more\")\n   - Mode selector: Radio buttons for \"Exact Insert\" vs \"Inspiration\"\n   - \"Use Template\" button → routes to /generate with templateId + mode params\n\n4. **API integration:**\n```typescript\nconst { data } = useQuery({\n  queryKey: ['templates', filters],\n  queryFn: () => fetch(`/api/ad-templates?${new URLSearchParams(filters)}`).then(r => r.json())\n});\n```\n\n5. **Styling:**\n- Use Radix UI components (Dialog for modal, Select for filters)\n- Tailwind CSS for layout\n- Mode badges: exact_insert (blue), inspiration (purple), standard (gray)\n- Loading skeleton for images\n\n6. **Accessibility:**\n- Keyboard navigation for grid\n- ARIA labels on filters\n- Focus management in modal",
        "testStrategy": "1. Visual regression test: Screenshot grid with 12 templates\n2. Test filtering: Select category → verify only matching templates shown\n3. Test modal: Click card → modal opens, close button works\n4. Test mode selection: Select mode → verify reflected in URL params\n5. Test responsive: Mobile (1 col), tablet (2 col), desktop (3-4 col)\n6. Test loading states: Show skeleton while fetching",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:55:34.218Z"
      },
      {
        "id": "5",
        "title": "Enhanced Idea Bank UI with Reasoning Display",
        "description": "Rebuild the Idea Bank panel to show AI suggestions with confidence scores, source indicators, and expandable reasoning explanations",
        "details": "Create `client/src/components/EnhancedIdeaBank.tsx` to replace current 4-button grid:\n\n**Layout:**\n1. **Header:**\n   - \"AI-Powered Ad Ideas\" title\n   - Product selector dropdown (if multiple products)\n   - \"Refresh Ideas\" button → re-calls /api/idea-bank/suggest\n\n2. **Suggestion cards** (vertical list, 3-5 cards):\n```tsx\n<Card key={suggestion.id}>\n  {/* Top row */}\n  <div className=\"flex justify-between\">\n    <Badge variant={suggestion.mode}>{suggestion.mode}</Badge>\n    <div className=\"flex gap-2\">\n      <ConfidenceIndicator value={suggestion.confidence} />\n      <SourceIcons sources={suggestion.sourcesUsed} />\n    </div>\n  </div>\n  \n  {/* Prompt preview */}\n  <p className=\"text-sm truncate-3-lines\">{suggestion.prompt}</p>\n  \n  {/* Expandable reasoning */}\n  <Collapsible>\n    <CollapsibleTrigger>Why this works ↓</CollapsibleTrigger>\n    <CollapsibleContent>\n      <p className=\"text-xs text-muted-foreground\">{suggestion.reasoning}</p>\n      <div className=\"mt-2\">\n        <span>Sources: </span>\n        {suggestion.sourcesUsed.visionAnalysis && <Badge>Vision</Badge>}\n        {suggestion.sourcesUsed.kbRetrieval && <Badge>Knowledge Base</Badge>}\n        {suggestion.sourcesUsed.templateMatching && <Badge>Templates</Badge>}\n      </div>\n    </CollapsibleContent>\n  </Collapsible>\n  \n  {/* Actions */}\n  <div className=\"flex gap-2 mt-4\">\n    <Button onClick={() => copyPrompt(suggestion.prompt)}>Copy Prompt</Button>\n    <Button variant=\"primary\" onClick={() => generateNow(suggestion)}>\n      Generate Now →\n    </Button>\n  </div>\n</Card>\n```\n\n3. **Components to create:**\n- `ConfidenceIndicator`: Progress bar (0-100%) with color gradient (red < 50, yellow 50-75, green > 75)\n- `SourceIcons`: Small icons for each source (eye=vision, book=KB, grid=templates)\n- `Modebadge`: Color-coded badge (exact_insert=blue, inspiration=purple, standard=gray)\n\n4. **Loading state:**\n- Skeleton loader showing 3 card outlines\n- \"Analyzing product...\" text\n\n5. **Empty state:**\n- \"No products selected\" message with CTA to upload product\n\n6. **API integration:**\n```typescript\nconst { data, isLoading } = useQuery({\n  queryKey: ['ideaBank', selectedProductIds],\n  queryFn: () => fetch('/api/idea-bank/suggest', {\n    method: 'POST',\n    body: JSON.stringify({ productIds: selectedProductIds, maxSuggestions: 5 })\n  }).then(r => r.json()),\n  enabled: selectedProductIds.length > 0\n});\n```\n\n7. **Integration with Home page:**\n- Replace current 4-button grid in `client/src/pages/Home.tsx`\n- Keep product selector above\n- Position below product grid, above generation history",
        "testStrategy": "1. Test with 1 product: Verify 3-5 suggestions appear\n2. Test confidence indicator: Mock suggestions with 30%, 60%, 90% → verify colors\n3. Test reasoning expansion: Click \"Why this works\" → content reveals\n4. Test \"Generate Now\": Should navigate to /generate with prompt + templateId pre-filled\n5. Test loading state: Mock slow API → verify skeleton shows\n6. Test empty state: No products → verify message shows\n7. Test multi-product: Select 3 products → verify suggestions consider all",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:56:29.674Z"
      },
      {
        "id": "6",
        "title": "Brand Profile Settings UI",
        "description": "Create a brand profile configuration page where users can set brand identity, target audience, and style preferences",
        "details": "Create `client/src/pages/BrandProfile.tsx` (new route: /settings/brand):\n\n**Form sections:**\n\n1. **Brand Identity** (top section)\n```tsx\n<Input label=\"Brand Name\" name=\"brandName\" />\n<Select label=\"Industry\" name=\"industry\" options={industriesEnum} />\n<TagInput label=\"Brand Values\" name=\"brandValues\" placeholder=\"eco-friendly, luxury, innovative...\" />\n```\n\n2. **Target Audience** (collapsible)\n```tsx\n<Textarea label=\"Demographics\" name=\"targetAudience.demographics\" \n  placeholder=\"Age range, income level, location, occupation...\" />\n<Textarea label=\"Psychographics\" name=\"targetAudience.psychographics\" \n  placeholder=\"Lifestyle, values, interests, behaviors...\" />\n<TagInput label=\"Pain Points\" name=\"targetAudience.painPoints\" />\n```\n\n3. **Visual Preferences** (collapsible)\n```tsx\n<CheckboxGroup label=\"Preferred Styles\" name=\"preferredStyles\" \n  options={['modern', 'rustic', 'minimalist', 'bold', 'traditional', 'contemporary']} />\n<CheckboxGroup label=\"Color Preferences\" name=\"colorPreferences\" \n  options={['neutral', 'vibrant', 'earth-tones', 'pastels', 'monochrome']} />\n```\n\n4. **Brand Voice** (syncs with users.brandVoice)\n```tsx\n<TagInput label=\"Voice Principles\" name=\"voice.principles\" \n  placeholder=\"professional, friendly, authoritative...\" />\n<TagInput label=\"Words to Use\" name=\"voice.wordsToUse\" />\n<TagInput label=\"Words to Avoid\" name=\"voice.wordsToAvoid\" />\n```\n\n5. **Knowledge Base Tags** (optional, advanced)\n```tsx\n<TagInput label=\"KB Filter Tags\" name=\"kbTags\" \n  placeholder=\"Tags to prioritize when searching knowledge base\" />\n```\n\n**API integration:**\n```typescript\n// Fetch existing profile\nconst { data: profile } = useQuery({\n  queryKey: ['brandProfile'],\n  queryFn: () => fetch('/api/brand-profile').then(r => r.json())\n});\n\n// Save profile\nconst mutation = useMutation({\n  mutationFn: (data) => fetch('/api/brand-profile', {\n    method: 'POST',\n    body: JSON.stringify(data)\n  }),\n  onSuccess: () => toast.success('Brand profile saved!')\n});\n```\n\n**UX details:**\n- Auto-save on blur (debounced 500ms)\n- \"Saved\" indicator (checkmark icon, fades after 2s)\n- Validation: At least brandName OR industry required\n- Tooltips explaining each field's impact on AI suggestions\n- Preview panel (right side): \"How this affects your ads\" with examples\n\n**Route setup:**\n- Add to `client/src/App.tsx`: `<Route path=\"/settings/brand\" element={<BrandProfile />} />`\n- Add nav link in settings sidebar",
        "testStrategy": "1. Test form submission: Fill all fields → POST to /api/brand-profile → verify saved\n2. Test auto-save: Type in field, wait 500ms → verify PATCH request sent\n3. Test validation: Submit empty form → verify error message\n4. Test TagInput: Add 3 tags → verify array saved correctly\n5. Test sync with brandVoice: Save voice.principles → verify users.brandVoice updated\n6. Test loading existing: User with profile → verify form pre-populated\n7. Integration test: Save profile, generate idea → verify profile influences suggestions",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:57:29.586Z"
      },
      {
        "id": "7",
        "title": "Implement Brand Profile API Endpoints",
        "description": "Create REST API endpoints for creating, reading, and updating brand profile configurations",
        "details": "Add to `server/routes.ts`:\n\n**GET /api/brand-profile**\n```typescript\napp.get('/api/brand-profile', requireAuth, async (req, res) => {\n  const userId = (req.session as any).userId;\n  const profile = await storage.getBrandProfileByUserId(userId);\n  \n  if (!profile) {\n    // Return default/empty profile structure\n    return res.json({\n      brandName: null,\n      industry: null,\n      brandValues: [],\n      targetAudience: { demographics: '', psychographics: '', painPoints: [] },\n      preferredStyles: [],\n      colorPreferences: [],\n      voice: { principles: [], wordsToUse: [], wordsToAvoid: [] },\n      kbTags: []\n    });\n  }\n  \n  res.json(profile);\n});\n```\n\n**POST /api/brand-profile** (create or full update)\n```typescript\napp.post('/api/brand-profile', requireAuth, async (req, res) => {\n  const userId = (req.session as any).userId;\n  \n  // Validate request body against insertBrandProfileSchema (from drizzle-zod)\n  const validated = insertBrandProfileSchema.parse(req.body);\n  \n  // Check if profile exists\n  const existing = await storage.getBrandProfileByUserId(userId);\n  \n  if (existing) {\n    // Update existing\n    const updated = await storage.updateBrandProfile(userId, validated);\n    \n    // Sync voice with users.brandVoice if provided\n    if (validated.voice) {\n      await storage.updateUserBrandVoice(userId, validated.voice);\n    }\n    \n    return res.json(updated);\n  }\n  \n  // Create new\n  const profile = await storage.saveBrandProfile({\n    ...validated,\n    userId\n  });\n  \n  // Sync voice\n  if (validated.voice) {\n    await storage.updateUserBrandVoice(userId, validated.voice);\n  }\n  \n  res.status(201).json(profile);\n});\n```\n\n**PATCH /api/brand-profile** (partial update, for auto-save)\n```typescript\napp.patch('/api/brand-profile', requireAuth, async (req, res) => {\n  const userId = (req.session as any).userId;\n  \n  // Allow partial updates\n  const updates = req.body; // Don't validate entire schema\n  \n  const profile = await storage.updateBrandProfile(userId, updates);\n  \n  // Sync voice if updated\n  if (updates.voice) {\n    await storage.updateUserBrandVoice(userId, updates.voice);\n  }\n  \n  res.json(profile);\n});\n```\n\n**Storage layer additions** (add to `server/storage.ts`):\n```typescript\nasync saveBrandProfile(profile: InsertBrandProfile): Promise<BrandProfile> {\n  const [result] = await db.insert(brandProfiles).values(profile).returning();\n  return result;\n}\n\nasync getBrandProfileByUserId(userId: string): Promise<BrandProfile | undefined> {\n  const [result] = await db.select().from(brandProfiles).where(eq(brandProfiles.userId, userId));\n  return result;\n}\n\nasync updateBrandProfile(userId: string, updates: Partial<InsertBrandProfile>): Promise<BrandProfile> {\n  const [result] = await db.update(brandProfiles)\n    .set({ ...updates, updatedAt: new Date() })\n    .where(eq(brandProfiles.userId, userId))\n    .returning();\n  return result;\n}\n```\n\n**Validation:**\n- Use zod schema from shared/schema.ts\n- Validate enums for industry, styles, colors\n- Sanitize text inputs (max lengths: brandName 100, demographics/psychographics 500)\n- Rate limit: 10 updates per minute per user",
        "testStrategy": "1. Test GET with no profile: Returns default structure\n2. Test POST new profile: Creates record, syncs brandVoice\n3. Test POST existing profile: Updates, not duplicates\n4. Test PATCH partial: Update single field (e.g., brandName)\n5. Test voice sync: Update voice.principles → verify users.brandVoice updated\n6. Test validation: Invalid industry enum → 400 error\n7. Test auth: No session → 401 error\n8. Integration test: Create profile via API, fetch via GET, verify match",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:57:37.221Z"
      },
      {
        "id": "8",
        "title": "Create Template Upload Admin UI",
        "description": "Build an admin-only interface for creating and managing ad scene templates with image upload and metadata configuration",
        "details": "Create `client/src/pages/TemplateAdmin.tsx` (route: /admin/templates):\n\n**Features:**\n\n1. **Template list view** (top half)\n   - Table with columns: Preview, Title, Category, Platform Hints, Actions\n   - Actions: Edit, Delete\n   - Filter by category\n   - \"Create New Template\" button\n\n2. **Template form modal** (click Create or Edit)\n```tsx\n<Form onSubmit={handleSubmit}>\n  {/* Basic info */}\n  <Input name=\"title\" label=\"Template Title\" required />\n  <Textarea name=\"description\" label=\"Description\" />\n  \n  {/* Image uploads */}\n  <FileInput name=\"previewImage\" label=\"Preview Image\" accept=\"image/*\" required />\n  <FileInput name=\"referenceImages\" label=\"Reference Images (up to 5)\" accept=\"image/*\" multiple max={5} />\n  \n  {/* Categorization */}\n  <Select name=\"category\" label=\"Category\" options={['lifestyle', 'professional', 'outdoor', 'luxury', 'seasonal']} required />\n  <TagInput name=\"tags\" label=\"Tags\" />\n  \n  {/* Platform targeting */}\n  <CheckboxGroup name=\"platformHints\" label=\"Platform Hints\" \n    options={['instagram', 'linkedin', 'facebook', 'twitter', 'tiktok']} />\n  <CheckboxGroup name=\"aspectRatioHints\" label=\"Aspect Ratio Hints\" \n    options={['1:1', '9:16', '16:9', '4:5']} />\n  \n  {/* Prompt engineering */}\n  <Textarea name=\"promptBlueprint\" label=\"Prompt Blueprint\" \n    placeholder=\"Use {{product}} as placeholder for product name\" required \n    rows={5} />\n  \n  {/* Placement */}\n  <Select name=\"placementHints.position\" label=\"Position\" \n    options={['center', 'left', 'right', 'top', 'bottom']} />\n  <Select name=\"placementHints.scale\" label=\"Scale\" \n    options={['small', 'medium', 'large', 'fill']} />\n  \n  {/* Advanced metadata */}\n  <Select name=\"lightingStyle\" label=\"Lighting Style\" \n    options={['natural', 'studio', 'dramatic', 'soft']} />\n  <Select name=\"intent\" label=\"Intent\" \n    options={['showcase', 'installation', 'before-after', 'scale-demo']} />\n  <Select name=\"environment\" label=\"Environment\" \n    options={['indoor', 'outdoor', 'studio', 'worksite']} />\n  <Select name=\"mood\" label=\"Mood\" \n    options={['luxury', 'cozy', 'industrial', 'minimal', 'vibrant']} />\n  <TagInput name=\"bestForProductTypes\" label=\"Best For Product Types\" \n    placeholder=\"flooring, furniture, decor...\" />\n  \n  {/* Access control */}\n  <Checkbox name=\"isGlobal\" label=\"Make Global (available to all users)\" defaultChecked />\n  \n  <Button type=\"submit\">Save Template</Button>\n</Form>\n```\n\n3. **Upload flow:**\n```typescript\nconst handleSubmit = async (formData) => {\n  // 1. Upload preview image to Cloudinary\n  const previewUpload = await uploadToCloudinary(formData.previewImage);\n  \n  // 2. Upload reference images (if any)\n  const referenceUploads = await Promise.all(\n    formData.referenceImages.map(img => uploadToCloudinary(img))\n  );\n  \n  // 3. Build template payload\n  const template = {\n    ...formData,\n    previewImageUrl: previewUpload.secure_url,\n    previewPublicId: previewUpload.public_id,\n    referenceImages: referenceUploads.map(u => ({\n      url: u.secure_url,\n      publicId: u.public_id\n    }))\n  };\n  \n  // 4. POST to /api/ad-templates\n  await fetch('/api/ad-templates', {\n    method: 'POST',\n    body: JSON.stringify(template)\n  });\n  \n  toast.success('Template created!');\n  refetch(); // Refresh list\n};\n```\n\n4. **Delete confirmation:**\n- Alert dialog: \"Are you sure? This will delete the template and its images from Cloudinary.\"\n- On confirm: DELETE /api/ad-templates/:id\n\n5. **Access control:**\n- Check user role (admin flag in session)\n- If not admin: redirect to /dashboard with error toast\n\n6. **Validation:**\n- Preview image required\n- Prompt blueprint must contain {{product}} placeholder\n- At least one platformHint or aspectRatioHint",
        "testStrategy": "1. Test admin access: Non-admin user → redirected\n2. Test create: Fill form, upload images → POST succeeds, template appears in list\n3. Test image upload: Select 1 preview + 3 references → verify 4 Cloudinary uploads\n4. Test validation: Submit without preview image → error shown\n5. Test placeholder check: Prompt without {{product}} → warning\n6. Test edit: Click edit, modify title → PATCH succeeds\n7. Test delete: Click delete, confirm → template removed from DB + Cloudinary\n8. Integration test: Create template via admin UI, verify appears in user's template library",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T21:02:27.317Z"
      },
      {
        "id": "9",
        "title": "Integrate Product Enrichment with Idea Bank",
        "description": "Wire up the existing ProductEnrichmentService to enhance Idea Bank suggestions with verified product knowledge",
        "details": "The codebase already has `productEnrichmentService.ts` and `productKnowledgeService.ts` but they're not fully integrated with the Idea Bank. Complete the integration:\n\n**1. Update ideaBankService.ts:**\n```typescript\n// Already has enhancedContext fetch (line 121-127), but needs enhancement:\n\nif (enhancedContext) {\n  // Add enriched product data to prompt context\n  const enrichmentData = {\n    description: product.description,\n    features: product.features,\n    benefits: product.benefits,\n    specifications: product.specifications,\n    tags: product.tags\n  };\n  \n  // Include in buildSuggestionPrompt (line 436)\n  prompt += `\\n## Enriched Product Data\\n${\n    Object.entries(enrichmentData)\n      .filter(([_, v]) => v)\n      .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)\n      .join('\\n')\n  }\\n`;\n}\n```\n\n**2. Add enrichment status to response:**\nIn `shared/types/ideaBank.ts`, AnalysisStatus already has `productKnowledgeUsed` (line 50). Enhance it:\n```typescript\nexport interface AnalysisStatus {\n  visionComplete: boolean;\n  kbQueried: boolean;\n  templatesMatched: number;\n  webSearchUsed: boolean;\n  productKnowledgeUsed: boolean;\n  enrichmentStatus?: 'pending' | 'draft' | 'verified' | 'complete'; // From products.enrichmentStatus\n}\n```\n\n**3. Update Idea Bank UI to show enrichment:**\nIn `client/src/components/EnhancedIdeaBank.tsx` (Task 5), add indicator:\n```tsx\n{data.analysisStatus.productKnowledgeUsed && (\n  <Tooltip content=\"Using verified product knowledge\">\n    <Badge variant=\"success\">\n      <CheckIcon /> Enriched Data\n    </Badge>\n  </Tooltip>\n)}\n```\n\n**4. Add enrichment prompt in Home.tsx:**\nIf product.enrichmentStatus === 'pending':\n```tsx\n<Alert>\n  <InfoIcon />\n  Product knowledge not enriched yet.\n  <Button variant=\"link\" onClick={() => navigate(`/products/${product.id}/enrich`)}>\n    Enrich Now →\n  </Button>\n</Alert>\n```\n\n**5. Update suggestion generation prompt:**\nWhen enrichmentStatus === 'verified', boost confidence scores by 10 points and add note:\n```typescript\nif (product.enrichmentStatus === 'verified') {\n  prompt += '\\n## NOTE: This product has verified enrichment data. Use it to generate highly accurate, brand-aligned suggestions.\\n';\n}\n```\n\n**6. Test with ProductEnrichmentForm:**\nVerify existing component at `client/src/components/ProductEnrichmentForm.tsx` works:\n- Submits enrichment data to /api/products/:id/enrich\n- Updates product.enrichmentDraft\n- User verifies → enrichmentStatus = 'verified'\n- Idea Bank picks up verified data",
        "testStrategy": "1. Test enrichment flow:\n   a. Upload product (enrichmentStatus = 'pending')\n   b. Call /api/idea-bank/suggest → verify productKnowledgeUsed = false\n   c. Enrich product via ProductEnrichmentForm\n   d. Verify draft → enrichmentStatus = 'verified'\n   e. Call /api/idea-bank/suggest again → productKnowledgeUsed = true\n2. Test prompt enhancement: Mock enriched product, verify prompt includes features/benefits\n3. Test UI indicator: Enriched product → verify badge shows\n4. Test confidence boost: Compare suggestions before/after enrichment → verify scores higher\n5. Integration test: Full flow from upload → enrich → verify → generate ideas",
        "priority": "low",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:58:52.144Z"
      },
      {
        "id": "10",
        "title": "Add Multi-Product Idea Bank Support",
        "description": "Enable Idea Bank to generate suggestions considering multiple products simultaneously for cross-product campaign ideas",
        "details": "The API already accepts `productIds[]` (line 1718 in routes.ts) but the service only processes single products. Extend to multi-product:\n\n**1. Update ideaBankService.generateSuggestions:**\n```typescript\nexport async function generateSuggestions(\n  request: IdeaBankRequest\n): Promise<{ success: true; response: IdeaBankSuggestResponse } | { success: false; error: IdeaBankError }> {\n  const { productIds, userId, userGoal, enableWebSearch = false, maxSuggestions = 3 } = request;\n  \n  if (!productIds || productIds.length === 0) {\n    return { success: false, error: { code: 'PRODUCT_NOT_FOUND', message: 'No products provided' } };\n  }\n  \n  // Fetch all products\n  const products = await Promise.all(\n    productIds.map(id => storage.getProductById(id))\n  ).then(results => results.filter(Boolean));\n  \n  if (products.length === 0) {\n    return { success: false, error: { code: 'PRODUCT_NOT_FOUND', message: 'No valid products found' } };\n  }\n  \n  // Analyze all products in parallel\n  const analyses = await Promise.all(\n    products.map(p => visionAnalysisService.analyzeProductImage(p, userId))\n  );\n  \n  const successfulAnalyses = analyses\n    .filter(a => a.success)\n    .map(a => a.analysis);\n  \n  // Build combined KB query\n  const kbQuery = buildMultiProductKBQuery(products, successfulAnalyses, userGoal);\n  \n  // Match templates based on combined product attributes\n  const matchedTemplates = await matchMultiProductTemplates(successfulAnalyses);\n  \n  // Generate suggestions considering all products\n  const suggestions = await generateMultiProductSuggestions({\n    products,\n    productAnalyses: successfulAnalyses,\n    // ... rest of params\n  });\n  \n  return { success: true, response: { suggestions, analysisStatus: { ... } } };\n}\n```\n\n**2. Add multi-product prompt engineering:**\n```typescript\nfunction buildMultiProductPrompt(products, analyses, ...) {\n  if (products.length === 1) {\n    return buildSingleProductPrompt(products[0], analyses[0], ...);\n  }\n  \n  let prompt = `Generate ad concept suggestions featuring MULTIPLE products together:\\n\\n`;\n  \n  products.forEach((product, i) => {\n    prompt += `### Product ${i + 1}: ${product.name}\\n`;\n    prompt += `- Category: ${analyses[i].category}\\n`;\n    prompt += `- Style: ${analyses[i].style}\\n`;\n    prompt += `- Colors: ${analyses[i].colors.join(', ')}\\n\\n`;\n  });\n  \n  prompt += `\\nCreate suggestions that:\\n`;\n  prompt += `1. Show all products working together cohesively\\n`;\n  prompt += `2. Highlight how the products complement each other\\n`;\n  prompt += `3. Tell a unified story across the products\\n`;\n  prompt += `4. Consider installation scenarios where products are used together\\n\\n`;\n  \n  return prompt;\n}\n```\n\n**3. Update frontend to support multi-select:**\nIn `client/src/pages/Home.tsx`:\n```tsx\nconst [selectedProductIds, setSelectedProductIds] = useState<string[]>([]);\n\n<div className=\"product-grid\">\n  {products.map(product => (\n    <ProductCard\n      key={product.id}\n      product={product}\n      selected={selectedProductIds.includes(product.id)}\n      onToggle={() => {\n        setSelectedProductIds(prev => \n          prev.includes(product.id)\n            ? prev.filter(id => id !== product.id)\n            : [...prev, product.id].slice(0, 6) // Max 6 products\n        );\n      }}\n    />\n  ))}\n</div>\n\n<Button \n  onClick={generateIdeas}\n  disabled={selectedProductIds.length === 0}\n>\n  Generate Ideas for {selectedProductIds.length} Product(s)\n</Button>\n```\n\n**4. Update suggestion display:**\nShow which products are featured in each suggestion:\n```tsx\n<Card>\n  <div className=\"flex gap-2 mb-2\">\n    {suggestion.featuredProductIds?.map(id => {\n      const product = products.find(p => p.id === id);\n      return <Avatar key={id} src={product?.cloudinaryUrl} size=\"xs\" />;\n    })}\n  </div>\n  {/* Rest of suggestion card */}\n</Card>\n```\n\n**5. Add productIds to suggestion response:**\n```typescript\nexport interface IdeaBankSuggestion {\n  // ... existing fields\n  featuredProductIds?: string[]; // Products featured in this suggestion\n}\n```",
        "testStrategy": "1. Test single product (backward compatibility): Select 1 → verify works as before\n2. Test 2 products: Select 2 → verify suggestions mention both products\n3. Test 6 products (max): Select 6 → verify all considered\n4. Test 7 products: Try selecting 7th → verify limited to 6\n5. Test template matching: 2 products with different categories → verify templates match both\n6. Test KB query: Multi-product → verify query combines both product contexts\n7. Test prompt quality: Generate with 3 products → manually verify suggestions show products working together\n8. Test UI: Selected products show checkmarks, featured products appear in suggestion cards",
        "priority": "low",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-28T20:59:00.084Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-28T21:02:27.319Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}